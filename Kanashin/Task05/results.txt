size	5	10	100	1K	10K	100K	1M	10M	100M

alg

bubble	0	0	0	0	0.7	87.17	n/a	n/a	n/a
insert	0	0	0	0	0.14	17.26	n/a	n/a	n/a
merge	0	0	0	0	0.01	0.05	0.64	8.6	n/a
quick	0	0	0	0	0	0.03	0.47	7.22	112.6
heap	0	0	0	0	0.01	0.06	1.11	17.04	300.5

В ходе эксперимента изначально использовался Gprof для проверки времени работы алгоритмов, но , например, для теста quick при 100М выводил чаще всего 20 секунд, при этом полная работа программы составляла около 200 секунд (т.е. с учетом времени на выделение памяти). В конечном итоге результаты были получены с помощью функции clock() заголовочного файла time.h стандартной библиотеки С.	

В качестве тестовых текстовых файлов были строки длиною в 5 символов. В таблице указано время работы алгоритма, которое чаще всего выводилось за 5 тестов.

Изначально была ошибка с памятью - не освобождал память в функции, реализующей сортировку слиянием. Как раз алгоритм сортировки слиянием не работает при 100М из-за нехватки места для выделения доп. памяти (на что как раз указывала ошибка при проверке на выделенную доп. память).

Вывод:
	Если при малых кол-вах строк (5-1000) асимптотика алгоритмов особо не влияла на время работы, то уже при больших кол-вах строк разница во времени работы оказывалась существенной. Существенные различия во времени работы между bubbleSort и insertSort стали заметны при 100K строк. Оба алгоритма работают за O(n^2), но при 100К insertSort быстрее bubbleSort примерно в 5-6 раз. Разница между mergeSort и quickSort, которые работают за O(n*logn),  заметна при 100М: для mergeSort требуется выделение дополнительной памяти в отличие от quickSort, что является ключом в разнице времени работы программы при этих алгоритмах. Различие между работой quickSort и heapSort (также работают O(n*logn) в среднем) вижу в количестве swap-ов в первом и в последнем.
